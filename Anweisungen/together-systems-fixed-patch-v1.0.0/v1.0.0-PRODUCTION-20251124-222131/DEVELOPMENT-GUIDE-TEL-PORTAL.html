<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>DEVELOPMENT-GUIDE-TEL-PORTAL</title>
<style>
body { font-family: system-ui; max-width: 800px; margin: 0 auto; padding: 20px; }
pre { background: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }
code { background: #f5f5f5; padding: 2px 4px; border-radius: 3px; }
</style>
</head>
<body>
<h2>TogetherSystems Portal – Entwicklungsleitfaden (Vertikalen, DB, Security, Psychologie)</h2>

Dieser Bericht ist für einen echten Entwickler / ein Team gedacht, um das aktuelle Demo‑System
(`ts-portal` auf Cloudflare Pages) in ein produktiv nutzbares Multi‑Vertical‑System zu verwandeln.

Er beschreibt:
1. Aktuellen Stand (was IST da)
2. Lücken (was FEHLT)
3. Konkrete Umsetzungsschritte je Schicht:
   - Vertikalen (Geschäfte)
   - Backend (D1 / APIs)
   - Security & Monitoring
   - Psychologie / AI‑Layer

---

<h3>1. Aktueller Stand (IST)</h3>

<strong>Frontend / UIs</strong>
- `index.html`: Offline‑Portal‑Start, Download‑Link fürs Manifest‑Forum.
- `manifest-forum.html`: Offline‑Forum (Single‑File), inkl. Verifizierungs‑Button „Portal öffnen (verifiziert)“.
- `manifest-portal.html`: Online‑Portal mit:
  - Feed‑Ansicht (Lesen),
  - Token‑Verifikation (Hash‑Parameter),
  - Auto‑Connect (Presence‑API, Match‑Loop),
  - Live‑Room‑Stub (WebSocket‑Signaling),
  - Voucher & Termine (inkl. Branch‑Templates + Kalender),
  - Immoblien & Hypotheken (Demo),
  - Events & Memberships‑Übersicht (Text‑Report aus Voucher‑API).
- `honeycomb.html`: Wabenräume (lokale Raum‑Logik).
- `legal-hub.html`: Rechtlicher Hub (Branding, Text) + lokale Contract‑Verknüpfung (Datei ↔ Voucher/Raum).
- `TELBANK/index.html`: Telbank‑Konsole (MetaMask‑Flows, In/Out, Transfer‑Logging).

<strong>Backend / Functions</strong>
- Cloudflare Pages Functions (im Verzeichnis `functions/`):
  - `api/telbank/transfers.js`: Telbank‑Transfers, aktuell bereits auf <strong>D1</strong> umgestellt (`env.DB` Binding, `transfers`‑Tabelle).
  - Presence‑API (`functions/api/presence/*.js`): Verify / Heartbeat / Match (In‑Memory‑Store, NICHT D1).
  - WebSocket‑Signaling (`functions/ws.js`): Räume + Broadcast (In‑Memory‑Store).
- Lokale Node‑Server (nicht auf Pages ausgerollt, nur für lokale Tests):
  - `voucher-api-server.js`: Voucher + Slots (In‑Memory).
  - `mortgage-api-server.js`: Hypothek‑Demo (In‑Memory).

<strong>Datenmodell / DB</strong>
- `d1-schema.sql`: Definiert Tabellen für:
  - `transfers` (Telbank),
  - `vouchers`, `voucher_bookings`,
  - `properties`, `mortgage_applications`, `mortgage_offers`.
- `BACKEND-ARCHITECTURE-DB-MONITORING-FEES.md`: beschreibt zusätzliche Tabellenideen (Events, Fees etc.).

---

<h3>2. Gaps (SOLLSOLL vs. IST)</h3>

<strong>Vertikalen:</strong>
- Maschinenzeit, Events, Memberships, Business‑Deals etc. existieren nur als:
  - Branch‑Buttons (Voucher‑Templates),
  - Text‑Karten im Portal,
  - Backend‑Schema.
- Es fehlen:
  - Eigene Oberflächen pro Vertical (Listen, Filter, Status, Detail‑Views),
  - Branch‑spezifische Business‑Regeln (z.B. Maschinen‑IDs, Standort, Verfügbarkeit, Stornoregeln),
  - Echte Verknüpfung zu Legal‑Hub (Contracts in D1 + R2).

<strong>Backend (D1 / APIs):</strong>
- Nur Telbank‑Transfers nutzen D1.
- Presence‑API, Voucher‑API, Mortgage‑API laufen noch in Memory / lokalen Node‑Prozessen.
- Kein einheitlicher Event‑/Audit‑Log.

<strong>Security & Monitoring:</strong>
- Keine Authentisierung (nur „Besitz“ eines Manifest‑Tokens),
- Keine Rate‑Limits,
- Kein globales Audit‑Log (`events`),
- Keine Admin‑Screens für Monitoring (nur einzelne Text‑Outputs).

<strong>Psychologie / AI:</strong>
- Konzepte (Telemetrie, Rage‑Clicks, UI‑Anpassung) sind beschrieben, aber:
  - keine echte Telemetrie‑Collection,
  - keine Auswertung,
  - kein Einfluss auf UI/Flows.

---

<h3>3. Phasenplan – Schrittweise Umsetzung</h3>

<h4>Phase 1: D1‑Backend für Voucher & Hypothek</h4>

Ziel: Lokale Node‑Server ablösen und Voucher/Hypothek‑Flows vollständig über D1‑Backends laufen lassen.

1. <strong>Voucher‑API nach D1 migrieren (Workers‑Stil)</strong>  
   - Neue Functions anlegen, z.B.:
     - `functions/api/voucher/issue.js`
     - `functions/api/voucher/list.js`
     - `functions/api/voucher/slots.js`
     - `functions/api/voucher/book.js`
     - `functions/api/voucher/cancel.js`
   - Implementierung: SELECT/INSERT/UPDATE gegen `vouchers` und `voucher_bookings` aus `d1-schema.sql`.
   - URL‑Schema: `/api/voucher/issue`, `/api/voucher/list`, `/api/slots/available`, etc., so dass `manifest-portal.html` nur die Basis `VOUCHER_API_BASE` von `http://localhost:3200/api` auf `/api` ändern muss.

2. <strong>Mortgage‑Demo nach D1 migrieren (optional, aber empfohlen)</strong>  
   - Functions:
     - `functions/api/mortgage/application.js` (POST),
     - `functions/api/mortgage/application-list.js` (GET),
     - `functions/api/mortgage/offer.js` (POST),
     - `functions/api/mortgage/offer-list.js` (GET).
   - Nutzung der Tabellen `properties`, `mortgage_applications`, `mortgage_offers`.

3. <strong>Portal‑Konfiguration anpassen</strong>
   - `manifest-portal.html`: `VOUCHER_API_BASE` von `http://localhost:3200/api` auf `'/api'` umstellen.
   - Mortgage‑Endpoints von `http://localhost:3300/...` auf `'/api/mortgage/...'` anpassen.

<h4>Phase 2: Vertikal‑UIs ausrollen</h4>

Ziel: Pro Vertical eine klar erkennbare UI, basierend auf Voucher/Hypothek‑Daten.

1. <strong>Maschinenzeit‑Konsole</strong>
   - Neues Panel, z.B. `machines.html` oder ein Abschnitt in `manifest-portal.html`:
     - Tabelle „Maschinen“, gespeist aus `vouchers` mit `service_type='machine.timeslot'`.
     - Spalten: Maschine (Titel), Standort, Preis, verfügbare Slots, Status.
     - Aktionen: „Slot buchen“, „Vertrag ansehen“ (Link zum Legal‑Hub mit `voucherId`).

2. <strong>Events‑Konsole</strong>
   - Filter auf `service_type IN ('consulting.session','therapy.session','realestate.viewing')`.
   - UI ähnlich: Liste der Sessions/Events, Slots, Buchungsstatus.

3. <strong>Membership‑Konsole</strong>
   - Filter auf `service_type='membership.access'`.
   - Anzeigen, welche Mitgliedschaften aktiv sind (Status, Zeitraum).

Alle drei Konsole nutzen dieselben Endpunkte wie „Voucher & Termine“, aber bieten eine <strong>branchen‑spezifische Sicht</strong>.

<h4>Phase 3: Legal‑Hub ↔ D1 & R2</h4>

Ziel: Verträge nicht nur lokal, sondern persistent mit D1 + R2 verknüpfen.

1. <strong>R2‑Bucket für Contracts</strong>  
   - Bucket z.B. `ts-contracts`, Binding `CONTRACTS_BUCKET`.

2. <strong>D1‑Tabellen erweitern</strong>  
   - `contracts` und `contract_links` wie in `BACKEND-ARCHITECTURE-DB-MONITORING-FEES.md` beschrieben anlegen:
     - `contracts`: Metadaten (name, mime_type, size, storage_url, hash).
     - `contract_links`: Mapping contract ↔ voucher ↔ room.

3. <strong>Upload‑Function</strong>  
   - `functions/api/contracts/upload.js`:
     - Erwartet `multipart/form-data` mit Datei, `voucherId`, `roomId`.
     - Speichert Datei in R2 (`CONTRACTS_BUCKET`), schreibt Metadaten in D1 (`contracts` + `contract_links`).

4. <strong>Legal‑Hub UI</strong>  
   - `legal-hub.html` so erweitern, dass:
     - vorhandene lokale Verknüpfungs‑Demo optional auf Online‑Upload umstellt,
     - Liste aus D1 geladen und angezeigt wird (echte Contracts).

<h4>Phase 4: Security & Monitoring</h4>

Ziel: Basis‑Security einziehen und Betriebsdaten sichtbar machen.

1. <strong>Auth‑Header / API‑Key light</strong>
   - In allen produktiven Functions (`voucher`, `mortgage`, `transfers`, `contracts`) optional einen Header wie `X-TS-APIKEY` auswerten.
   - Keys in D1 in einer `api_keys`‑Tabelle pflegen (oder `wrangler secret` / Secrets Store).

2. <strong>Rate‑Limit light</strong>
   - Einfache Drosselung per IP + Zeitfenster, z.B. über R2/KV oder D1‑Tabelle `rate_limits` (Key, Count, Window).
   - Minimal: pro Function‐Aufruf prüfen, ob über Schwellwert.

3. <strong>Events‑Tabelle & Audit‑Log</strong>
   - In D1 Tabelle `events` anlegen (siehe Architektur‑Dok).
   - In jeder Function bei Erfolg einen Event schreiben:
     - `presence.heartbeat`, `voucher.issue`, `voucher.book`, `transfer.logged`, `contract.upload`, …

4. <strong>Monitoring‑UI</strong>
   - Eine einfache Admin‑Seite (z.B. `admin-monitoring.html`), die:
     - Summen und letzte N Events aus `/api/admin/events` anzeigt,
     - Statistiken für Transfers, Voucher‑Buchungen, Hypotheken‑Anfragen rendert.

<h4>Phase 5: Psychologie / AI‑Layer</h4>

Ziel: Telemetrie und psychologische Indikatoren sammeln und (vorsichtig) auf UI/Flows anwenden.

1. <strong>Telemetrie‑Client</strong>
   - `psy-telemetry.js`: sammelt Events wie:
     - Klick‑Pfad, Abbrüche, „Rage Clicks“, Verweilzeiten.
   - Schickt diese an `/api/telemetry` (Workers‑Function, die in D1‑Tabelle `telemetry_events` schreibt).

2. <strong>Mini‑Analyzer</strong>
   - Periodische Auswertung (z.B. Worker‑Cron oder manuell):
     - Welche Panels verursachen viele Abbrüche?
     - Wo häufen sich Errors / 500er?

3. <strong>UI‑Anpassung light</strong>
   - Anfänglich nur Hinweise/Tooltips:
     - z.B. wenn viele Nutzer nicht verstehen, wie Voucher funktioniert, zeige automatisch kurze Hilfetexte.
   - Keine „Black‑Box‑AI“, sondern nachvollziehbare Regeln auf Basis der Telemetrie.

---

<h3>4. Tooling & Betrieb</h3>

<strong>Wrangler / Deploy</strong>
- Standard‑Deploy:
  - `wrangler pages deploy . --project-name ts-portal`

<strong>D1</strong>
- Vorhandene DB verwenden (`wrangler d1 list`).
- Schema migrieren:
  - `wrangler d1 execute <dbName> --file=./d1-schema.sql`

<strong>R2</strong>
- Bucket anlegen, Binding im Pages‑Projekt setzen (`CONTRACTS_BUCKET`).

---

<h3>5. Checkliste für Entwickler</h3>

1. Bestehende D1‑DB auswählen (`wrangler d1 list`) und Schema ausführen.
2. Binding `DB` im Pages‑Projekt sicherstellen.
3. Voucher‑API als Workers‑Functions nach D1 heben, `manifest-portal.html` auf `/api` umstellen.
4. Mortgage‑Demo optional nach D1 heben.
5. Drei Vertikal‑UIs im Portal ausrollen:
   - Maschinenzeit‑Konsole,
   - Events‑Konsole,
   - Membership‑Konsole.
6. Legal‑Hub an D1 + R2 anschließen (Contracts & Links).
7. Basic Auth‑Header + Rate‑Limit in produktiven Functions einführen.
8. Events‑Tabelle + Monitoring‑UI bauen.
9. Telemetrie‑Client + `/api/telemetry` hinzufügen, spätere UI‑Anpassung vorbereiten.

Dieser Leitfaden beschreibt, was <strong>konkret</strong> fehlt und wie es sich Stück für Stück implementieren lässt,
ohne das System zu zerbrechen – so dass aus der jetzigen Demo‑Architektur eine real nutzbare Plattform werden kann.
</body>
</html>